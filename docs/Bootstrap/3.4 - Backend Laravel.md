# 🚀 Backend Laravel - Documentation Complète

## 🎯 Objectif
Créer un backend PHP 8.2 avec Laravel 11 qui reproduise exactement les fonctionnalités du backend Spring Boot existant, respectant l'architecture Clean Architecture et les spécifications techniques fournies.

## 🔧 Stack Technique Recommandée

### ✅ Versions & Outils
- **PHP** : 8.2 (version LTS, support jusqu'en 2028)
- **Laravel** : 11.x (version la plus récente, avec support officiel)
- **ORM** : Eloquent (inclus avec Laravel)
- **Base de données** : 
  - **PostgreSQL** (production) via Docker
  - **SQLite** (tests) pour une configuration légère
- **Validation** : Laravel Validation (équivalent à Jakarta Validation)
- **Mapping DTO** : Spatie Data Transfer Object (ou Laravel Resources)
- **Tests** : PHPUnit + Pest (framework de test populaire pour Laravel)
- **API Documentation** : Laravel Sanctum (optionnel, pour l'authentification) + Postman

### 📦 Extensions & Packages Recommandés
```bash
# Installer les packages essentiels
composer require laravel/breeze --dev  # Pour l'authentification (si besoin)
composer require spatie/data-transfer-object  # Pour les DTO
composer require laravel/legacy-factories  # Compatibilité avec les factories
composer require nunomaduro/larastan --dev  # Pour le typage statique
```

## 🏗️ Architecture Clean Architecture - Mapping Spring Boot → Laravel

### 📌 Couches de l'Architecture

| **Spring Boot** | **Laravel Équivalent** | **Description** |
|------------------|-------------------------|-----------------|
| `domain/model`   | `app/Domain/Models`     | Entités métiers (immuables) |
| `application/dao`| `app/Application/Repositories` | Interfaces de données |
| `application/service` | `app/Application/Services` | Logique métier |
| `infrastructure/jpa` | `app/Infrastructure/Persistence` | Implémentations Eloquent |
| `infrastructure/api` | `app/Http/Controllers` | Contrôleurs REST |

### 📝 Exemples de Composants

#### 1. Entités Métiers (Domain Layer)
```php
// app/Domain/Models/Task.php
<?php

namespace App\Domain\Models;

use Carbon\CarbonImmutable;
use Illuminate\Support\Uuid;

class Task
{
    public function __construct(
        public readonly Uuid $id,
        public string $title,
        public ?string $description,
        public string $status,
        public string $priority,
        public ?CarbonImmutable $dueDate,
        public CarbonImmutable $createdAt,
        public CarbonImmutable $updatedAt,
        public ?Uuid $assigneeId,
        public ?User $assignee = null
    ) {}

    // Business methods
    public function isCompleted(): bool
    {
        return $this->status === 'DONE';
    }
}
```

#### 2. Interfaces de Données (Application Layer)
```php
// app/Application/Repositories/TaskRepositoryInterface.php
<?php

namespace App\Application\Repositories;

use App\Domain\Models\Task;
use Illuminate\Support\Collection;
use Illuminate\Support\Uuid;

interface TaskRepositoryInterface
{
    public function findAll(): Collection;
    public function findById(Uuid $id): ?Task;
    public function findByAssigneeId(Uuid $userId): Collection;
    public function save(Task $task): Task;
    public function update(Task $task): Task;
    public function delete(Task $task): bool;
}
```

#### 3. Implémentations Eloquent (Infrastructure Layer)
```php
// app/Infrastructure/Persistence/EloquentTaskRepository.php
<?php

namespace App\Infrastructure\Persistence;

use App\Application\Repositories\TaskRepositoryInterface;
use App\Domain\Models\Task;
use App\Infrastructure\Persistence\Eloquent\Models\EloquentTask;
use Illuminate\Support\Collection;
use Illuminate\Support\Uuid;

class EloquentTaskRepository implements TaskRepositoryInterface
{
    public function __construct(private readonly EloquentTask $eloquentTask) {}

    public function findAll(): Collection
    {
        return $this->eloquentTask->all()->map(fn(EloquentTask $et) => $this->toDomain($et));
    }

    public function findById(Uuid $id): ?Task
    {
        $eloquentTask = $this->eloquentTask->find($id);
        return $eloquentTask ? $this->toDomain($eloquentTask) : null;
    }

    // ... autres méthodes

    private function toDomain(EloquentTask $eloquentTask): Task
    {
        return new Task(
            id: Uuid::fromString($eloquentTask->id),
            title: $eloquentTask->title,
            description: $eloquentTask->description,
            status: $eloquentTask->status,
            priority: $eloquentTask->priority,
            dueDate: $eloquentTask->due_date ? CarbonImmutable::parse($eloquentTask->due_date) : null,
            createdAt: CarbonImmutable::parse($eloquentTask->created_at),
            updatedAt: CarbonImmutable::parse($eloquentTask->updated_at),
            assigneeId: $eloquentTask->assignee_id ? Uuid::fromString($eloquentTask->assignee_id) : null,
        );
    }
}
```

#### 4. Services Métier (Application Layer)
```php
// app/Application/Services/TaskService.php
<?php

namespace App\Application\Services;

use App\Application\Repositories\TaskRepositoryInterface;
use App\Domain\Models\Task;
use App\Domain\Exceptions\TaskNotFoundException;
use Illuminate\Support\Uuid;

class TaskService
{
    public function __construct(private readonly TaskRepositoryInterface $taskRepository) {}

    /**
     * @throws TaskNotFoundException
     */
    public function getTaskById(Uuid $id): Task
    {
        $task = $this->taskRepository->findById($id);
        if (!$task) {
            throw new TaskNotFoundException("Task with id {$id} not found");
        }
        return $task;
    }

    public function createTask(Task $task): Task
    {
        return $this->taskRepository->save($task);
    }

    // ... autres méthodes métier
}
```

#### 5. Contrôleurs REST (Infrastructure Layer)
```php
// app/Http/Controllers/TaskController.php
<?php

namespace App\Http\Controllers;

use App\Application\Services\TaskService;
use App\Domain\Models\Task;
use App\Http\Requests\StoreTaskRequest;
use App\Http\Resources\TaskResource;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Uuid;

class TaskController extends Controller
{
    public function __construct(private readonly TaskService $taskService) {}

    public function index(): JsonResponse
    {
        $tasks = $this->taskService->getAllTasks();
        return response()->json(TaskResource::collection($tasks));
    }

    public function show(Uuid $id): JsonResponse
    {
        try {
            $task = $this->taskService->getTaskById($id);
            return response()->json(new TaskResource($task));
        } catch (TaskNotFoundException $e) {
            return response()->json([
                'timestamp' => now()->toIso8601String(),
                'status' => 404,
                'error' => 'Not Found',
                'message' => $e->getMessage(),
                'path' => request()->url(),
                'errorId' => Uuid::generate()
            ], 404);
        }
    }

    // ... autres méthodes
}
```

## 🔌 API Structure - Conformité aux Spécifications

### ✅ Routes REST
Toutes les routes seront préfixées par `/api/v1` et respecteront la convention kebab-case :

```php
// routes/api.php
use App\Http\Controllers\TaskController;
use App\Http\Controllers\UserController;

Route::prefix('v1')->group(function () {
    Route::apiResource('tasks', TaskController::class)->only([
        'index', 'store', 'show', 'update', 'destroy'
    ]);
    
    Route::post('tasks/batch', [TaskController::class, 'batchStore']);
    Route::delete('tasks/batch', [TaskController::class, 'batchDestroy']);
    
    Route::get('users/{userId}/tasks', [TaskController::class, 'getTasksByUserId']);
});
```

### ✅ Validation des Entrées
Utilisation de Laravel Validation pour équivalent à Jakarta Validation :

```php
// app/Http/Requests/StoreTaskRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreTaskRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'title' => 'required|string|max:255',
            'description' => 'nullable|string',
            'status' => 'required|in:TODO,IN_PROGRESS,DONE',
            'priority' => 'required|in:LOW,MEDIUM,HIGH,URGENT',
            'due_date' => 'nullable|date',
            'assignee_id' => 'nullable|uuid',
        ];
    }
}
```

## 🧪 Tests - Equivalent à JUnit + Mockito

### ✅ Tests Unitaires
Utilisation de PHPUnit avec mocking :

```php
// tests/Unit/Application/Services/TaskServiceTest.php
<?php

namespace Tests\Unit\Application\Services;

use App\Application\Repositories\TaskRepositoryInterface;
use App\Application\Services\TaskService;
use App\Domain\Models\Task;
use App\Domain\Exceptions\TaskNotFoundException;
use Illuminate\Support\Uuid;
use Mockery;
use PHPUnit\Framework\TestCase;

class TaskServiceTest extends TestCase
{
    public function testGetTaskByIdThrowsExceptionWhenNotFound()
    {
        $taskId = Uuid::generate();
        $mockRepository = Mockery::mock(TaskRepositoryInterface::class);
        $mockRepository->shouldReceive('findById')->with($taskId)->andReturnNull();

        $taskService = new TaskService($mockRepository);

        $this->expectException(TaskNotFoundException::class);
        $this->expectExceptionMessage("Task with id {$taskId} not found");
        
        $taskService->getTaskById($taskId);
    }
}
```

### ✅ Tests d'Intégration
Utilisation de Laravel's testing suite avec base de données SQLite :

```php
// tests/Feature/Http/Controllers/TaskControllerTest.php
<?php

namespace Tests\Feature\Http\Controllers;

use App\Domain\Models\Task;
use App\Infrastructure\Persistence\Eloquent\Models\EloquentTask;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Carbon;
use Illuminate\Support\Uuid;
use Tests\TestCase;

class TaskControllerTest extends TestCase
{
    use RefreshDatabase;

    public function testIndexReturnsTasks()
    {
        EloquentTask::factory()->count(3)->create();

        $response = $this->getJson('/api/v1/tasks');

        $response->assertStatus(200)
            ->assertJsonCount(3);
    }
}
```

## 🗄️ Gestion de la Base de Données

### ✅ Migrations
Création des tables avec Laravel Migrations :

```php
// database/migrations/2025_09_24_120000_create_users_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('username')->unique();
            $table->string('email')->nullable()->unique();
            $table->string('role')->default('USER');
            $table->timestamps();
        });
    }
};
```

### ✅ Fixtures de Test
Utilisation de Laravel Factories pour les données de test :

```php
// database/factories/UserFactory.php
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class UserFactory extends Factory
{
    public function definition(): array
    {
        return [
            'id' => Str::uuid(),
            'username' => fake()->unique()->userName(),
            'email' => fake()->unique()->safeEmail(),
            'role' => fake()->randomElement(['USER', 'ADMIN']),
        ];
    }
}
```

## 🔒 Sécurité & Gestion des Erreurs

### ✅ Centralisation des Erreurs
Création d'un handler global pour les exceptions :

```php
// app/Exceptions/Handler.php
<?php

namespace App\Exceptions;

use App\Domain\Exceptions\TaskNotFoundException;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Support\Uuid;
use Symfony\Component\HttpFoundation\Response;

class Handler extends ExceptionHandler
{
    public function render($request, \Throwable $e)
    {
        if ($e instanceof TaskNotFoundException) {
            return response()->json([
                'timestamp' => now()->toIso8601String(),
                'status' => Response::HTTP_NOT_FOUND,
                'error' => 'Not Found',
                'message' => $e->getMessage(),
                'path' => $request->url(),
                'errorId' => Uuid::generate()
            ], Response::HTTP_NOT_FOUND);
        }

        return parent::render($request, $e);
    }
}
```

### ✅ CORS Configuration
Activation de CORS pour le frontend Angular :

```php
// config/cors.php
return [
    'paths' => ['api/*'],
    'allowed_methods' => ['*'],
    'allowed_origins' => ['http://localhost:4200'],
    'allowed_headers' => ['*'],
    'exposed_headers' => [],
    'max_age' => 0,
    'supports_credentials' => false,
];
```

## 🚀 Étapes de Mise en Place

### 1. Initialisation du Projet
```bash
# Créer un nouveau projet Laravel
composer create-project laravel/laravel task-management-laravel "11.*"

# Configurer la base de données (PostgreSQL)
# Éditer .env :
DB_CONNECTION=pgsql
DB_HOST=127.0.0.1
DB_PORT=5432
DB_DATABASE=task_management
DB_USERNAME=postgres
DB_PASSWORD=postgres

# Créer la base de données via Docker
docker run --name postgres-task -e POSTGRES_DB=task_management -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 -d postgres:15
```

### 2. Installation des Packages
```bash
# Installer les dépendances essentielles
composer require spatie/data-transfer-object
composer require nunomaduro/larastan --dev
composer require laravel/pint --dev # Pour le formatage de code
```

### 3. Configuration de l'Architecture Clean
```bash
# Créer les répertoires de l'architecture
mkdir -p app/Domain/Models
mkdir -p app/Application/Services
mkdir -p app/Application/Repositories
mkdir -p app/Infrastructure/Persistence
mkdir -p app/Infrastructure/Persistence/Eloquent/Models
```

### 4. Création des Composants
Suivre l'exemple des fichiers fournis précédemment pour créer :
- Modèles métiers
- Interfaces de repositories
- Implémentations Eloquent
- Services métier
- Contrôleurs REST
- Resources DTO

### 5. Tests
```bash
# Exécuter les tests
php artisan test

# Générer la couverture de code
php artisan test --coverage
```

## 📚 Sources & Justifications

### ✅ Choix Techniques
1. **Laravel 11** : Version la plus récente avec de nombreuses améliorations (blade components, routing amélioré, etc.)
2. **Eloquent ORM** : Équivalent mature et largement utilisé à Spring Data JPA
3. **Spatie Data Transfer Object** : Solution populaire pour le mapping DTO (alternatives : Laravel Resources)
4. **PHPUnit + Pest** : Écosystème de test mature pour PHP
5. **PostgreSQL** : Base de données relationnelle robuste, conforme aux spécifications

### ✅ Conformité aux Spécifications
- ✅ Architecture Clean Architecture respectée
- ✅ API REST conforme à la structure fournie
- ✅ Gestion des erreurs avec format JSON standardisé
- ✅ Validation des entrées
- ✅ Tests unitaires et d'intégration
- ✅ CORS configuré pour le frontend Angular
